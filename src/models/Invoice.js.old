const mongoose = require('mongoose');

const lineItemSchema = new mongoose.Schema({
  description: { type: String, required: true },
  quantity: { type: Number, default: 1 },
  unitPrice: { type: Number, required: true },
  amount: { type: Number, required: true },
  confidence: { type: Number, min: 0, max: 1, default: 1 },
});

const invoiceSchema = new mongoose.Schema({
  // File Information
  originalFileName: { type: String, required: true },
  filePath: { type: String, required: true },
  fileType: { type: String, enum: ['pdf', 'png', 'jpg', 'jpeg', 'tiff'], required: true },
  fileSize: { type: Number, required: true },

  // Processing Status
  status: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'failed', 'review_required'],
    default: 'pending',
  },
  processingStartedAt: Date,
  processingCompletedAt: Date,
  processingTimeMs: Number,

  // Extracted Data
  vendorName: { type: String },
  vendorAddress: { type: String },
  vendorEmail: { type: String },
  vendorPhone: { type: String },

  invoiceNumber: { type: String },
  invoiceDate: { type: Date },
  dueDate: { type: Date },
  purchaseOrderNumber: { type: String },

  // Customer Information
  customerName: { type: String },
  customerAddress: { type: String },

  // Financial Data
  lineItems: [lineItemSchema],
  subtotal: { type: Number },
  taxRate: { type: Number },
  taxAmount: { type: Number },
  discountAmount: { type: Number },
  shippingAmount: { type: Number },
  totalAmount: { type: Number },
  currency: { type: String, default: 'USD' },

  // Payment Information
  paymentTerms: { type: String },
  paymentMethod: { type: String },
  bankDetails: { type: String },

  // Validation & Quality
  confidenceScore: { type: Number, min: 0, max: 1 },
  validationErrors: [{ type: String }],
  validationWarnings: [{ type: String }],
  isValidated: { type: Boolean, default: false },
  requiresManualReview: { type: Boolean, default: false },

  // Anomalies & Flags
  anomalies: [{
    field: String,
    message: String,
    severity: { type: String, enum: ['low', 'medium', 'high'] },
  }],

  // Raw Extraction Data
  rawExtractionData: { type: mongoose.Schema.Types.Mixed },

  // User Corrections
  corrections: [{
    field: String,
    originalValue: mongoose.Schema.Types.Mixed,
    correctedValue: mongoose.Schema.Types.Mixed,
    correctedAt: { type: Date, default: Date.now },
    correctedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  }],

  // Batch Processing
  batchId: { type: String },

  // Integration
  exportedTo: [{ type: String }], // e.g., ['quickbooks', 'xero']
  externalIds: { type: Map, of: String },

  // Webhook
  webhookUrl: { type: String },
  webhookSent: { type: Boolean, default: false },
  webhookSentAt: { type: Date },

  // Retry Information
  retryCount: { type: Number, default: 0 },
  lastError: { type: String },

  // Metadata
  createdBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  tags: [{ type: String }],
  notes: { type: String },

}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
});

// Indexes for performance
invoiceSchema.index({ status: 1, createdAt: -1 });
invoiceSchema.index({ invoiceNumber: 1 });
invoiceSchema.index({ vendorName: 1 });
invoiceSchema.index({ batchId: 1 });
invoiceSchema.index({ createdBy: 1 });

// Virtual for calculated line items total
invoiceSchema.virtual('calculatedSubtotal').get(function() {
  if (!this.lineItems || this.lineItems.length === 0) return 0;
  return this.lineItems.reduce((sum, item) => sum + (item.amount || 0), 0);
});

// Method to check if calculations are valid
invoiceSchema.methods.validateCalculations = function() {
  const errors = [];

  // Check line items
  for (let i = 0; i < this.lineItems.length; i++) {
    const item = this.lineItems[i];
    const expectedAmount = item.quantity * item.unitPrice;
    if (Math.abs(item.amount - expectedAmount) > 0.01) {
      errors.push(`Line item ${i + 1}: Amount mismatch (expected ${expectedAmount}, got ${item.amount})`);
    }
  }

  // Check subtotal
  const calculatedSubtotal = this.calculatedSubtotal;
  if (this.subtotal && Math.abs(this.subtotal - calculatedSubtotal) > 0.01) {
    errors.push(`Subtotal mismatch (expected ${calculatedSubtotal}, got ${this.subtotal})`);
  }

  // Check total
  const expectedTotal = (this.subtotal || 0) + (this.taxAmount || 0) - (this.discountAmount || 0) + (this.shippingAmount || 0);
  if (this.totalAmount && Math.abs(this.totalAmount - expectedTotal) > 0.01) {
    errors.push(`Total mismatch (expected ${expectedTotal}, got ${this.totalAmount})`);
  }

  return errors;
};

// Static method for batch processing stats
invoiceSchema.statics.getBatchStats = async function(batchId) {
  return this.aggregate([
    { $match: { batchId } },
    {
      $group: {
        _id: '$status',
        count: { $sum: 1 },
        avgConfidence: { $avg: '$confidenceScore' },
        avgProcessingTime: { $avg: '$processingTimeMs' },
      },
    },
  ]);
};

module.exports = mongoose.model('Invoice', invoiceSchema);
